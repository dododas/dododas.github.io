'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/2021/2021-01-31-matplotlib-rw/','title':"Animations with matplotlib - 2: Random walks",'content':"This post is the second in a series on how to use the matplotlib.animation module to create animated plots. The examples here use this module to create animations of 2D random walks.\nIntroduction matplotlib1 is a python library for creating high quality scientific plots. It contains a module matplotlib.animation to create animations. This post shows examples of using this module to create some interesting visualizations of 2D random walks.\nRandom walks Random walks2 are models for many physical phenomena, such as the movement of molecules in a liquid or gas, and the diffusion of proteins on the cell membrane. To simulate a random walk, a particle is placed at some initial position $\\bold{r}_0 = (x_0, y_0)$ and advanced using the recursion relation:\n$$ \\bold{r}_{j+1} = (x_j + \\delta x, y_j + \\delta y) $$\nThe displacement along each axis is a normally distributed random variable: $$ \\delta x, \\delta y \\sim \\cal{N}(0, \\sigma) $$\nThis algorithm produces a Gaussian random walk. The standard deviation $\\sigma$ of the normal distribution is related to the diffusion coefficient of the particle3.\nIn the examples below, particles are initially placed within a small central region of the simulation domain. Each particle moves independently, following the random walk algorithm above. Over time, the aggregated random motion of the particles disperses them like a drop of ink mixing in water.\nExamples These examples follow a common template:\n Set up an empty plot Initialize with plot elements, eg: points in their initial location Update plot element attributes, eg: change point coordinates  Step 3 is repeated at each frame to advance the animation. The function FuncAnimation() implements these steps.\nFirst, Load the needed libraries\nimport numpy as np import matplotlib.pyplot as plt import matplotlib as mpl import matplotlib.animation as anim from IPython.display import HTML from pathlib import Path Example 1: Diffusing particles The first simulation shows the position of particles over time. In the next code block, init() plots the particles in their initial position, move() updates particle positions using the random walk algorithm above, and FuncAnimation() uses these functions as inputs to generate the animation:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # Initialize particle positions within a central square  nparticles = 50 r0 = 0.45 + 0.1 * np.random.rand(nparticles, 2) # Create figure fig, ax = plt.subplots(figsize = (5, 5)) pos = [ax.plot([], [], \u0026#34;o\u0026#34;, color = \u0026#34;C3\u0026#34;, ms = 6, alpha = 0.8)[0] for j in range(nparticles)] # Plot initial particle positions def init(): for jj, p in enumerate(pos): p.set_data(r0[jj, 0], r0[jj, 1]) # Fix plot appearance ax.set_xlim([0, 1]) ax.set_xticks([]) ax.set_ylim([0, 1]) ax.set_yticks([]) ax.set_title(\u0026#34;Example 1: Brownian motion\u0026#34;) return(pos) # Update particle positions def move(k, sigma = 0.01): # Apply random normal displacement along each axis for p in pos: x, y = p.get_data() dx, dy = tuple(sigma * np.random.randn(2)) p.set_data(x + dx, y + dy) return(pos) ani = anim.FuncAnimation(fig, move, init_func = init, frames = 300, interval = 50, blit = True)   The resulting output shows how particles diffuse and disperse away from their initial locations.\n   Example 2: Particle tracks The next example plots the trajectory of each particle. To do this efficiently, first simulate the entire trajectory for each particle, and store all trajectories in a numpy array:\n1 2 3 4 5 6 7 8 9 10 11  def simulate_rw(nparticles = 15, nframes = 200, sigma = 0.01): \u0026#34;\u0026#34;\u0026#34;Simulate trajectories of diffusing particles\u0026#34;\u0026#34;\u0026#34; # Initialize particle positions displacements = np.zeros((nframes, 2, nparticles)) displacements[0, :, :] = 0.45 + 0.1 * np.random.rand(2, nparticles) # Simulate Brownian random walk displacements[1:, :, :] = np.random.normal(scale = sigma, size = (nframes-1, 2, nparticles)) # Compute positions r = np.cumsum(displacements, axis = 0) return(r)   Then plot the trajectories by showing the progress up to each frame. Note how the function set_markevery() is used to display both the marker and the line for each track.\n12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  # Generate tracks positions = simulate_rw() nframes, _, nparticles = positions.shape # Create figure fig, ax = plt.subplots(figsize = (5, 5)) pts = [ax.plot([], [], \u0026#34;-o\u0026#34;, alpha = 0.8)[0] for j in range(nparticles)] # Plot initial particle positions def init(): r0 = positions[0,:,:] for jj, p in enumerate(pts): p.set_data(r0[0, jj], r0[1, jj]) # Set plot appearance ax.set_xlim([0, 1]) ax.set_xticks([]) ax.set_ylim([0, 1]) ax.set_yticks([]) return(pts) # Update particle positions def move(k): for jj, p in enumerate(pts): r = positions[:k+1, :, jj] p.set_data(r[:, 0], r[:, 1]) p.set_markevery((k, k+1)) return(pts) ani = anim.FuncAnimation(fig, move, init_func = init, frames = nframes, interval = 50, blit = True)   The output shows how diffusing particles explore space:\n   Example 3: Particle trails In this example, the animaiton shows a \u0026ldquo;trail\u0026rdquo; behind each particle rather than the complete trajectory. The maximum trail length can be changed in the move() function below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  # Create figure fig, ax = plt.subplots(figsize = (5, 5)) pts = [ax.plot([], [], \u0026#34;-o\u0026#34;, alpha = 0.85)[0] for j in range(nparticles)] # Plot initial particle positions def init(): r0 = positions[0,:,:] for jj, p in enumerate(pts): p.set_data(r0[0, jj], r0[1, jj]) # Set plot appearance ax.set_xlim([0, 1]) ax.set_xticks([]) ax.set_ylim([0, 1]) ax.set_yticks([]) return(pts) # Update particle positions def move(k, trail = 30): for jj, p in enumerate(pts): if (k \u0026lt;= trail): r = positions[:k+1, :, jj] n = k else: r = positions[(k+1 - trail):k+1, :, jj] n = trail-1 p.set_data(r[:, 0], r[:, 1]) p.set_markevery((n, n+1)) return(pts) ani = anim.FuncAnimation(fig, move, init_func = init, frames = nframes, interval = 50, blit = True)   which produces the following output\n   Summary and references These examples demonstrate how the matplotlib.animation module can be used to create dynamic visualizations. The complete code for this post is available in this jupyter notebook\nReferences:\n https://matplotlib.org/3.3.3/api/animation_api.html https://towardsdatascience.com/animations-with-matplotlib-d96375c5442c https://brushingupscience.com/2016/06/21/matplotlib-animations-the-easy-way/ https://brushingupscience.com/2019/08/01/elaborate-matplotlib-animations/ Download Jupyter notebook with code    https://matplotlib.org/ \u0026#x21a9;\u0026#xfe0e;\n https://en.wikipedia.org/wiki/Random_walk \u0026#x21a9;\u0026#xfe0e;\n $\\sigma = \\sqrt{2Dt}$ where $D$ is the diffusion coefficient, and $t$ is the time interval between observation \u0026#x21a9;\u0026#xfe0e;\n  "});index.add({'id':1,'href':'/','title':"Home",'content':"Welcome! My name is Raibatak Das. I am a senior scientist at Applied BioMath, LLC. This is my personal web page.\nPlease click on the links to learn more about me and my work.\n   "});index.add({'id':2,'href':'/tags/matplotlib/','title':"matplotlib",'content':""});index.add({'id':3,'href':'/posts/','title':"Posts",'content':""});index.add({'id':4,'href':'/tags/python/','title':"python",'content':""});index.add({'id':5,'href':'/tags/random-walk/','title':"random walk",'content':""});index.add({'id':6,'href':'/tags/','title':"Tags",'content':""});index.add({'id':7,'href':'/posts/2021/2021-01-17-matplotlib-waves/','title':"Animations with matplotlib 1: Making waves",'content':"This is the first part of a series on how to use the matplotlib.animation module to create animated plots. The examples here show how to visualize traveling waves and the phenomenon of superposition.\nIntroduction matplotlib1 is a python library for creating high quality scientific plots. It contains a module matplotlib.animation that can be used to create animations. This post shows examples of using this module to visualize wave motion.\nBackground This is a short technical background on wave motion that explains the ideas behind the code examples below\nWave equation Mathematically, wave motion is described by a partial differential equation called the wave equation. A 1-D version of the wave equation has the following form: $$ \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2} $$\nwhere $u(x, t)$ is the solution for some given initial conditions - usually the initial position $u(x, 0)$ and initial velocity $\\partial u / \\partial t (x, 0)$ of the system.\nThe examples below simulate the solution to the wave equation for a plucked string of length $L$ that is anchored at two ends. At time 0, the string is pulled in the middle to create an inverted v-shape, and then let go. The solution $u(x, t)$ is the vertical position of the string at subsequent times. The initial position of the string is the piecewise function: $$u(x, 0) = \\begin{cases} \\frac{x}{L/2} \u0026amp; \\text{for } 0 \\leq x \u0026lt; L/2 \\\\ \\frac{L - x}{L/2} \u0026amp; \\text{for } L/2 \\leq x \\leq L \\end{cases} $$ and its initial velocity is $\\partial u / \\partial t(x, 0) = 0$.    Initial position of plucked string\n    Traveling waves One way to solve the wave equation is by using traveling waves. A traveling wave is a function of the form: $$ u(x, t) = f(x \\pm ct) $$ At time $t = 0$, the function $f(x)$ is a shape in space. Replacing $x$ by $x-ct$ transposes this shape to the right by a distance $ct$. Therefore, $f(x - ct)$ is the shape $f(x)$ traveling to the right at the speed $c$. The first set of animations simulate traveling waves.\nSuperposition A traveling wave is a general solution of the wave equation. The wave equation is linear, which means any linear combination of solutions is also a solution. More strongly, it can be shown that all solutions to the wave equation are of the form: $$u(x, t) = F(x + ct) + G(x - ct)$$ that is, a superposition of two traveling waves.\nThe specific solution for the plucked string problem is trivially simple. Given the initial shape, $f(x)$, and assuming the string is stationary at time 0, the subsequent motion of the string is2: $$u(x, t) = \\frac{1}{2} \\left[ f(x + ct) + f(x - ct) \\right] $$ This is known as the d\u0026rsquo;Alembert solution to the wave equation.\nThe second set of animations visualize this solution for the plucked string problem.\nExamples The examples below show how to use matplotlib.animation to create animations of traveling waves. These examples follow a common template:\n Create a plot with the initial shape $y = f(x) = u(x, 0)$ Update the shape by applying the transform $f(x) \\to f(x - ct)$  The function FuncAnimation() creates the animation by repeatedly calling the update function.\nFirst load the needed libraries:\nimport numpy as np import matplotlib.pyplot as plt import matplotlib as mpl import matplotlib.animation as anim from IPython.display import HTML from pathlib import Path Example 1: Traveling waves The first example produces a traveling sine wave:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  f = lambda x: np.sin(x) x = np.linspace(-np.pi, np.pi, 100) y = f(x) # Initialize plot fig, ax = plt.subplots(figsize = (7, 5)) wave, = ax.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C3\u0026#34;, lw = 2) ax.set_xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi]) ax.set_xticklabels((r\u0026#34;-$\\pi$\u0026#34;, r\u0026#34;-$\\pi/2$\u0026#34;, \u0026#34;0\u0026#34;, r\u0026#34;$\\pi/2$\u0026#34;, r\u0026#34;$\\pi$\u0026#34;)) ax.set_yticks((-1, 0, 1)) ax.grid(True) ax.set_title(r\u0026#34;A traveling sine wave: $u(x, t) = \\sin(x - ct)$\u0026#34;) # Transpose f(x) -\u0026gt; f(x - ct) def shift(t, c = 1): # Transpose the wave new_y = f(x - c*t) wave.set_ydata(new_y) return(wave,) # Set up animation ani = anim.FuncAnimation(fig, shift, frames = 190, fargs = (0.1,), interval = 30, blit = True)   This produces the following animation:\n   The function $f()$ can have any arbitrary shape. For example, this next animation code block produces a traveling wave packet whose shape is defined by the first highlighted line. Also note how changing the velocity to a negative value (see second highlighted line) changes the direction of traveling wave.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # Define shape of wavepacket x = np.linspace(-np.pi, np.pi, 200) f = lambda x: np.exp(- x**2 / 2) * np.cos(10*x) y = f(x) # Initialize plot fig, ax = plt.subplots(figsize = (7, 5)) wavepacket, = ax.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C3\u0026#34;, lw = 2) ax.set_xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi]) ax.set_xticklabels((r\u0026#34;-$\\pi$\u0026#34;, r\u0026#34;-$\\pi/2$\u0026#34;, \u0026#34;0\u0026#34;, r\u0026#34;$\\pi/2$\u0026#34;, r\u0026#34;$\\pi$\u0026#34;)) ax.set_yticks((-1, 0, 1)) ax.set_title(r\u0026#34;A wave packet\u0026#34;) # Transpose f(x) -\u0026gt; f(x - ct) def shift(t, c = 1): # Transpose the wave new_y = f(x - c*t) wavepacket.set_ydata(new_y) return(wavepacket,) # Animate ani = anim.FuncAnimation(fig, shift, frames = 200, fargs = (-0.03,),  interval = 30, blit = True)      Example 2: Superposition The next set of examples visuailzes the d\u0026rsquo;Alembert solution to the wave equation for a plucked string that is anchored at $x = 0$ and $x = \\pi$, and at time $t = 0$ is in the inverted-V configuration. The initial shape $f(x)$ is defined over $x \\in [0, \\pi]$. To construct the traveling wave solution, first extend this over entire real line by constructing an odd periodic extension\ndef y(x): \u0026#34;\u0026#34;\u0026#34;Odd periodic extension of plucked string\u0026#34;\u0026#34;\u0026#34; pi = np.pi x = x % (2 * pi) if (x \u0026lt; pi/2): h = x / (pi/2) elif (x \u0026gt;= pi/2) and (x \u0026lt; 3 * pi/2): h = 1 - (x - pi/2)/(pi/2) else: h = (x - 2*pi)/(pi/2) return(h) f = np.vectorize(y) The extended function $f(x)$ looks like this:   Next, use this periodic extension to construct two traveling waves. The superposition of these traveling waves produces the dynamics of the plucked string as shown in this animation:\n   This animation is the output of the following code block:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  # Compute initial shape of string x = np.append(np.linspace(0, np.pi, 99), np.pi/2) x.sort() y = f(x) # Plot initial shape fig, (ax0, ax1) = plt.subplots(figsize = (7, 6), nrows = 2, sharex = \u0026#34;all\u0026#34;, sharey = \u0026#34;all\u0026#34;) plt.subplots_adjust(hspace = 0.3) rwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C2\u0026#34;, label = r\u0026#34;$f(x - ct)$\u0026#34;) lwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C1\u0026#34;, label = r\u0026#34;$f(x + ct)$\u0026#34;) string, = ax1.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C0\u0026#34;, lw = 2) ax0.set_title(r\u0026#34;Traveling waves\u0026#34;) ax0.legend(loc = \u0026#34;lower right\u0026#34;) ax1.set_title(r\u0026#34;Superposition: $[f(x + ct) + f(x - ct)]/2$\u0026#34;) ax1.set_xticks([0, np.pi/2, np.pi]) ax1.set_xticklabels((\u0026#34;0\u0026#34;, r\u0026#34;$\\pi/2$\u0026#34;, r\u0026#34;$\\pi$\u0026#34;)) for ax in (ax0, ax1): ax.set_ylim([-1.1, 1.1]) ax.set_yticks((-1, 0, 1)) ax.grid(True) # Compute traveling wave solution def shift(t, c = 1): # Transpose each traveling wave new_r, new_l = f(x - c*t), f(x + c*t) new_y = (new_l + new_r)/2 rwave.set_ydata(new_r) lwave.set_ydata(new_l) string.set_ydata(new_y) return(lwave, rwave, string) # Animate ani = anim.FuncAnimation(fig, shift, frames = 189, fargs = (0.1,), interval = 30, blit = True)   Example 3: Varying initial shape The final examples use the traveling wave solution to simulate a vibrating string with different initial shapes. The shapes are created using interpolation. The next animation shows the behavior for an asymmetric shape:\n   This is generated using the following code block:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  # Plucked string with asymmetric initial shape from scipy import interpolate def y2(x): \u0026#34;\u0026#34;\u0026#34;Odd periodic extension of plucked string\u0026#34;\u0026#34;\u0026#34; pi = np.pi # Use linear interpolation to generate initial shape x0, y0 = [0, pi/4, pi, 7*pi/4, 2*pi], [0, 1, 0, -1, 0] u0 = interpolate.interp1d(x0, y0) # Make periodic x = x % (2 * pi) return(u0(x)) f2 = np.vectorize(y2) # Generate initial shape x = np.append(np.linspace(0, np.pi, 98), np.pi/4) x.sort() y = f2(x) # Plot initial shape fig, (ax0, ax1) = plt.subplots(figsize = (7, 6), nrows = 2, sharex = \u0026#34;all\u0026#34;, sharey = \u0026#34;all\u0026#34;) plt.subplots_adjust(hspace = 0.3) lwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C1\u0026#34;, label = r\u0026#34;$f(x + ct)$\u0026#34;) rwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C2\u0026#34;, label = r\u0026#34;$f(x - ct)$\u0026#34;) string, = ax1.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C0\u0026#34;, lw = 2) ax0.set_title(r\u0026#34;Traveling waves\u0026#34;) ax0.legend(loc = \u0026#34;lower right\u0026#34;) ax1.set_title(r\u0026#34;Superposition: $[f(x + ct) + f(x - ct)]/2$\u0026#34;) ax1.set_xticks([0, np.pi/2, np.pi]) ax1.set_xticklabels((\u0026#34;0\u0026#34;, r\u0026#34;$\\pi/2$\u0026#34;, r\u0026#34;$\\pi$\u0026#34;)) for ax in (ax0, ax1): ax.set_ylim([-1.1, 1.1]) ax.set_yticks((-1, 0, 1)) ax.grid(True) # Compute traveling wave solution def shift(t, c = 1): # Transpose each traveling wave new_l, new_r = f2(x + c*t), f2(x - c*t) new_y = (new_l + new_r)/2 rwave.set_ydata(new_r) lwave.set_ydata(new_l) string.set_ydata(new_y) return(lwave, rwave, string) # Animate ani = anim.FuncAnimation(fig, shift, frames = 189, fargs = (0.1,), interval = 30, blit = True)   The last example uses a higher order interpolation to produce a smoother initial shape that looks more natural.\n   This is the output of the following code block\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  # Traveling wave solution to plucked string  # with asymmetric initial shape def y3(x): \u0026#34;\u0026#34;\u0026#34;Odd periodic extension of plucked string\u0026#34;\u0026#34;\u0026#34; pi = np.pi # Use cubic interpolation to generate smooth initial shape x0 = np.linspace(0, 2*pi, 9) y0 = f2(x0) u0 = interpolate.interp1d(x0, y0, kind = 3) x = x % (2 * pi) return(u0(x)) f3 = np.vectorize(y3) # To work on numpy arrays # Generate initial shape x = np.append(np.linspace(0, np.pi, 98), np.pi/4) x.sort() y = f3(x) # Plot initial shape fig, (ax0, ax1) = plt.subplots(figsize = (7, 6), nrows = 2, sharex = \u0026#34;all\u0026#34;, sharey = \u0026#34;all\u0026#34;) plt.subplots_adjust(hspace = 0.3) lwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C1\u0026#34;, label = r\u0026#34;$f(x + ct)$\u0026#34;) rwave, = ax0.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C2\u0026#34;, label = r\u0026#34;$f(x - ct)$\u0026#34;) string, = ax1.plot(x, y, \u0026#34;-\u0026#34;, color = \u0026#34;C0\u0026#34;, lw = 2) ax0.set_title(r\u0026#34;Traveling waves\u0026#34;) ax0.legend(loc = \u0026#34;lower right\u0026#34;) ax1.set_title(r\u0026#34;Superposition: $[f(x + ct) + f(x - ct)]/2$\u0026#34;) ax1.set_xticks([0, np.pi/2, np.pi]) ax1.set_xticklabels((\u0026#34;0\u0026#34;, r\u0026#34;$\\pi/2$\u0026#34;, r\u0026#34;$\\pi$\u0026#34;)) for ax in (ax0, ax1): ax.set_ylim([-1.1, 1.1]) ax.set_yticks((-1, 0, 1)) ax.grid(True) # Compute traveling wave solution def shift(t, c = 1): # Transpose each traveling wave new_l, new_r = f3(x + c*t), f3(x - c*t) new_y = (new_l + new_r)/2 rwave.set_ydata(new_r) lwave.set_ydata(new_l) string.set_ydata(new_y) return(lwave, rwave, string) # Animate ani = anim.FuncAnimation(fig, shift, frames = 189, fargs = (0.1,), interval = 30, blit = True)   Summary and References These examples demonstrate how the matplotlib.animation module can be used to create dynamic visualizations. The complete code for this post is available in this jupyter notebook\nReferences:\n https://matplotlib.org/3.3.3/api/animation_api.html https://towardsdatascience.com/animations-with-matplotlib-d96375c5442c https://brushingupscience.com/2016/06/21/matplotlib-animations-the-easy-way/ https://brushingupscience.com/2019/08/01/elaborate-matplotlib-animations/ Chapter 1 of Fourier Analysis - An Introduction by Stein \u0026amp; Shakarchi Partial Differential Equations for Scientists and Engineers by Farlow Download jupyter notebook with code    https://matplotlib.org/ \u0026#x21a9;\u0026#xfe0e;\n If the initial velocity is not 0, then the full solution is: $$u(x, t) = \\frac{1}{2} \\left[ f(x + ct) + f(x - ct) \\right] + \\frac{1}{2c} \\int_{x - ct}^{x + ct} g(y) dy $$ \u0026#x21a9;\u0026#xfe0e;\n  "});index.add({'id':8,'href':'/tags/waves/','title':"waves",'content':""});index.add({'id':9,'href':'/posts/2020/2020-01-02-test-post/','title':"Test post",'content':"This is a sample post to test the appearance and layout. This site is created using the static site generator Hugo\nSyntax highlighting Here is a code block with syntax highlighting using Chroma\ndef fib(n): a, b = 0, 1 while a \u0026lt; n: print(a, end = \u0026#39; \u0026#39;) a, b = b, a+b print() fib(1000) Math rendering Math is rendered using KaTeX. This is an inline expression: $\\textcolor{#228B22}{e^{i \\theta} = \\cos \\theta + i \\sin \\theta}$\nAnd below is a display mode expression:\n$$e^z = \\lim_{n \\to \\infty} \\left(1 + \\frac{z}{n} \\right)^n$$\n"});index.add({'id':10,'href':'/categories/','title':"Categories",'content':""});index.add({'id':11,'href':'/docs/','title':"Docs",'content':""});})();